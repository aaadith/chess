chess - design blueprint


position
{int rank, file}

enum color {black, white}

abstract class coin
{
	color
	position
	
	
	coin(color, position)
	{
	 this.color = color;
	 this.position = position;
	}
	
	abstract bool isValidMove(position from, position to);
	abstract Set<position> GetValidMoves();
}

pawn : coin
{	
}

rook : coin
{	
}

knight : coin
{
}

bishop : coin
{
}

king : coin
{
}

queen : coin
{
}


move
{
	position from, to
	coin 
}


class player
{
	color
	gameManager
	
	player(enum color, GameManager gameManager)
	{
		this.color = color;
		this.gameManager = gameManager;
	}
	
	move play()
	{
		move result = null
		
		move lastmove = gameManager.moves.peek();

		if(lastmove.isCheck)
			lastmove.isCheckmate = isCheckmate();
		
		if(lastmove.ischeckmate)
			return result
		
		move m = getUserInput();
		coin c = m.coin;
		
		//check if player is moving his coin
		if(player.color != c.color)
			return result
		
		to = m.to;
		
		if(!c.getValidMoves().contains(to))
			return result
		
		if(!isValidTargetPosition(to))
			return result
			
		if(lastmove.ischeck && !isCheckResolved())
			return result
		
		m.isCheck = isCheck();
		
			
		result = m;
		return result;
	}
	
	isValidTargetPosition(position to)
	{
		//a target position is valid if:
		//1. it is currently empty 
		//2. or it is occupied by opposite player's coin
		
	}
	
	isCheckResolved()
	{
		//checkpoint board at current state
		//get possible moves for opposite players coins after current move
		//check if any of these moves leads to check
	}
	
	isCheck()
	{
		//get possible moves for current players coins after current move
		//check if any of those moves contains opposite player's king's position
	}
	
	isCheckMate()
	{
		//check if king can move to any non-check position
		//if not
		//for each of current player's coin c in board:
		// get all valid moves
		// check if any of the moves can resolve check
	}
	
	
	move getUserInput()
	{
	
	}
}



class GameManager
{
	Dictionary<position, coin> board;
	player player1, player2;
	
	stack<move> moves;
	
	
	GameManager()
	{
		position pos_white_king = new position(x,y);
		white_king = new king(color.white, pos_white_king );
		
		board[pos_white_king] = white_king;
		
		white_pawn1 = new pawn(color.white, new position() );
		
		...//instantiate all coins place all coins on board in their initial positions
		...//use abstract factory pattern here
		
		
		player1 = new player(color.white, board);
		player2 = new player(color.black, board);
		moves = new stack<move>();
		
		ManageGame();
	}
	
	void ManageGame()
	{
		while(!IsGameOver())
		{
			player = GetPlayer();
			move = player.play();
			coin = move.coin;
			if(coin.isValidMove(move))
			{
				moves.add(move);
				coin.position = move.to;
				board.remove(move.from);
				board[move.to] = coin;
			}
		}
	}
	
	bool IsGameOver()
	{
		
	}
	
	player GetPlayer()
	{
		if(moves.empty)
			return player1
		
		lastmovecolor = moves.peek().color
		if(lasmovecolor=white)
			return player2
		return player1;
	}
	
}
